## Introduction
The repository implements a simple Forum API as described [here](https://github.com/cunla/interview-question/blob/master/q3.md).
This is a SpringBoot application that can simply be run by executing:
```
mvn spring-boot:run
```
from the root.
The service runs on port 5000.

## OAS
This application is configured to generate the OAS for the API. When the application is running, OAS can be accessed at `http://localhost:5000/v3/api-docs/`.
The application uses spring-doc to generate OAS.

## Libraries used in the project
* Guava: Some streaming and transformations functions on collections are used from this library.

### Code generation
* Mapstruct: Mappings between Data Transfer Objects (DTOs) and entities are auto-generated using Mapstruct.
* Lombok: Lombok is also used for generation of boiler plate code for POJOs and injecting loggers.  

### Testing
* AssertJ: Test assertions are primarily written using AssertJ.
* Mockito: Unit testing is primarily based on Mockito. The usage is limited to mocks and verifications. Project doesn't have the use of spies or mock beans. 

### DB Migrations
* Flyway: Flyway is included in the project to manage the DB migrations.

## Coverage
The project users jacoco plugin to generate coverage report. The process executes as part of the tests. Running `mvn test` generates coverage report under `./target/site/jacoco`.
There is very limited test coverage for `toString`, `hashCode` and `equals` functions generated by `Lombok` that throws off the overall coverage. 

## Java Docs
Maven plugin for Java Docs have also been included in the project for ease. Executing `mvn javadoc:javadoc` generates Java Docs under `./target/site/apidocs`.

## Some implementation notes
### ApplicationEvent (informally captured ADR)
One of the architectural choices made in this project is the use of `ApplicationEvent`. The only usecase for which `ApplicationEvent` has been used is maintaining counts of the replies on a `Question`.
The API requires returning number of replies for each Question in the list returned by `GET:/questions` endpoint. One naive solution would be to join the `question` and `reply` entities and count. This is clearly not an efficient solution from query perspective.
A `reply_count` field is added to the `question` entity to keep a count. With this approach, we need to maintain that field everytime a reply is added. One simpler approach would have been to update that count from the service layer when reply is added.
The risk in that approach is the possibility of loosing track of this update when the service evolves or if reply entities are added to the DB from other places.
In order to mitigate this risk, an `EventListener` is registered to process `@PostPersist` event on `ReplyEntity`. When processing that event, `ReplyAddedEvent (ApplicationEvent)` is published using `ApplicationEventPublisher`, which is then processed in `ForumService` to update the reply count on the corresponding `QuestionEntity`. 

### Retrieving the list of Questions
`GET:/questions` would ideally be paged in a realistic implementation. Even though, this was not part of the specs, it's a sensible thing to do. It has been left out in this implementation. When paging is implemented, `PagingAndSortingRepository` can be used. 
An important consideration is to use `Slice` instead of `Page` when going for this implementation as `Page` triggers an additional unnecessary `count(*)` query everytime a page request is made.  

### Use of EntityGraph
`EntityGraph` is used to do an eager fetch of `replies` associated with `questions` when calling `GET:/questions/{questionId}`, whereas the joined column on the `QuestionEntity` is marked for `LAZY` fetching.
